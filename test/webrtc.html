<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <link rel="stylesheet" href="css/mocha.css" />
    
    <title>Playing with WebRTC</title>
    
    <script src="../lib/xs-min.js"></script>
    
    <script src="/socket.io/socket.io.js"></script>
  </head>
  
  <body>
    <div id=""></div>
    <table>
      <tr>
        <th>
          Local
        </th>
        <th>
          Remote
        </th>
      </tr>
      <tr id='videos'>
      </tr>
    </table>
    
    <script>
      var xs = XS.xs
        , Pipelet = XS.Pipelet
        , Set = XS.Set
        , log = XS.log
        , de = true
        , ug = function( m ) { XS.log( 'webrtc, ' + m ) }
        , get_user_media = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia
        , URL = window.URL
        , constraints  = { audio: false, video: { mandatory: { maxWidth: 320, maxHeight: 240 } } }
        , caller_video = document.querySelector( "#caller" )
        , callee_video = document.querySelector( "#callee" )
        , RTCPeerConnection, RTCSessionDescription, RTCIceCandidate
        , caller_peer_connection
        , callee_peer_connection
        , configuration // = [ { "url": "stun:stun.services.mozilla.com" } ]
        , caller_channel
      ;
      
      function HTML5_Video( container, options ) {
        options = Set.call( this, [], options )._options;
        
        de&&ug( 'html5_video(), container: ' + container + ', options: ' + log.s( this._options) );
        
        container = this._container = document.querySelector( container );
        
        if ( ! options.element ) {
          options.element = {
            TR: 'td',
            UL: 'li'
          }[ container.tagName ] || 'div';
        }
        
        return this;
      }
      
      Set.Build( 'html5_video', HTML5_Video, function( Super ) { return {
        _add_value: function( t, v ) {
          var id = v.id
            , stream = source_from_stream( v.stream )
            , $video = document.querySelector( '#' + id )
          ;
          
          if ( ! $video ) {
            var e = this._options.element;
            
            var $e = document.createElement( e );
            
            $e.innerHTML = '<video id="' + id + '"  autoplay></video>';
            
            this._container.appendChild( $e );
            
            $video = document.querySelector( '#' + id );
          }
          
          de&&ug( this._get_name( '_add_value' ) + 'id: ' + id );
          
          $video.src = stream;
          
          return Super._add_value.call( this, t, v );
        },
        
        _remove_value: function( t, v ) {
          var id = v.id
            , $video = document.querySelector( '#' + id )
          ;
          
          de&&ug( this._get_name( '_remove_value' ) + 'id: ' + id );
          
          video.src = null;
          
          $video = $video.parentNode;
          
          $video.parentNode.removeChild( $video );
          
          return Super._remove_value.call( this, t, v );
        }
      }; } );
      
      var video = xs.html5_video( '#videos' );
      
      if ( navigator.webkitGetUserMedia ) {
        // Chrome
        RTCPeerConnection = webkitRTCPeerConnection;
        
        de&&ug( 'Chrome RTCPeerConnection: ' + typeof RTCPeerConnection );
      } else if ( navigator.mozGetUserMedia ) {
        // Firefox
        RTCPeerConnection = mozRTCPeerConnection;
        RTCSessionDescription = mozRTCSessionDescription;
        RTCIceCandidate = mozRTCIceCandidate;
        
        de&&ug( 'Firefox RTCPeerConnection: ' + typeof RTCPeerConnection );
      }
      de&&ug( 'RTCSessionDescription: ' + typeof RTCSessionDescription );
      de&&ug( 'RTCIceCandidate: ' + typeof RTCIceCandidate );
      
      if ( ! RTCPeerConnection ) throw new Error( 'Browser does not support WebRTC' );
      
      de&&ug( 'get_user_media(), constraints: ' + log.s( constraints ) );
      
      // User media is a first pipelet
      get_user_media && get_user_media.call( navigator, constraints, on_stream, on_error ); 
      
      function source_from_stream( stream ) {
        if ( URL ) {
          // Chrome
          stream = URL.createObjectURL( stream );
          
          de&&ug( 'source_from_stream(), URL.createObjectURL( stream ): ' + log.pretty( stream ) );
        }
        
        return stream;
      }
      
      // This should be an audio / video capture pipelet
      function on_stream( stream ) {
        de&&ug( 'on_stream(), stream: ' + log.pretty( stream ) );
        
        // ToDo: move to downstream video pipelet
        video._add( [ { id: 'caller', stream: stream } ] );
        
        //caller_video.play();
        
        de&&ug( 'on_stream(), playing caller video' );
        
        // Additional info, only available in Chrome for now
        de && stream.getVideoTracks && ug( "video tracks: " + log.s( stream.getVideoTracks() ) );
        de && stream.getAudioTracks && ug( "audio tracks: " + log.s( stream.getAudioTracks() ) );          
        
        // Call is handled by downstream pipelet
        // But the caller may not always be this party which may in some cases be the callee
        call( stream );
      }
      
      function call( stream ) {
        var peer = caller_peer_connection
          = new RTCPeerConnection( configuration, { optional: [ { RtpDataChannels: true } ] } );
        
        de&&ug( 'caller_peer_connection: ' + log.s( caller_peer_connection ) );
        
        peer.onicecandidate = function( event ) {
          var candidate = event.candidate;
          
          if ( candidate ) {
            // Send caller ice candidate to callee
            
            add.call( callee_peer_connection, [
              { flow: 'webrtc', from: 'caller', to: 'callee', name: 'ice_candidate', event: candidate }
            ] );
          } else {
            de&&ug( 'no more callee candidates, event keys: ' + log.s( Object.keys( event ) ) );
          }
        };
        
        peer.onaddstream = function( event ) {
          de&&ug( 'On caller stream received event: ' + log.s( event.stream ) );
          
          // ToDo: move to a downstream pipelet
          // This stream is comming from camera directly
          caller_video.src = source_from_stream( event.stream );
          caller_video.style.opacity = 1;
        };
        
        caller_channel = peer.createDataChannel( 'xs_channel', { reliable: false } );
        
        caller_channel.onmessage = function( event ) {
          de&&ug( 'channel ' + caller_channel.label + ', caller received data: ' + event.data );
        }
        
        // Add the stream to the caller peer
        peer.addStream( stream );
        peer.createOffer( offer_ready, make_error( 'caller_peer_connection.createOffer' ) );
        
        function offer_ready( description ) {
          de&&ug( 'offer_ready(), description sdp: ' + description.sdp );
          
          peer.setLocalDescription( description );
          
          // Send description to callee
          add.call( callee_peer_connection, [
            { flow: 'webrtc', from: 'callee', to: 'caller', name: 'offer', event: description }
          ] );
        }
      }
      
      var calls = [];
      
      // add() webrtc signaling events processing
      // this: caller or callee peer connection object
      function add( values ) {
        for ( var i = -1, v; v = values[ ++i ]; ) {
          var name = v.name, from = v.from, to = v.to, description, candidate, that = this;
          
          de&&ug( 'add(), received event ' + name + ' for ' + to + ' from ' + from );
          
          switch( name ) {
            case 'offer':
              // configuration is an option of this pipelet or may come from a control pipelet
              callee_peer_connection = peer
                = new RTCPeerConnection( configuration, { optional: [ { RtpDataChannels: true } ] } );
              
              de&&ug( 'callee_peer_connection: ' + log.s( callee_peer_connection ) );
              
              peer.onicecandidate = function( event ) {
                var candidate = event.candidate;
                
                // Send callee candidates to caller
                if ( candidate ) {
                  add.call( caller_peer_connection, [
                    { flow: 'webrtc', from: to, to: from, name: 'ice_candidate', event: candidate }
                  ] );
                } else {
                  de&&ug( 'no more caller candidates, event keys: ' + log.s( Object.keys( event ) ) );
                }
              };
              
              peer.onaddstream = function( event ) {
                de&&ug( 'On callee stream received event: ' + log.s( event.stream ) );
                
                // ToDo: use _emit_add()
                video._add( [ { id: 'callee', stream: event.stream } ] );
              };
              
              peer.ondatachannel = function( event ) {
                var channel = event.channel, label = channel.label;
                
                de&&ug( 'callee data channel: ' + log.pretty( channel ) );
                
                channel.onmessage = function( event ) {
                  de&&ug( 'channel ' + label + ', callee received data: ' + event.data );
                  
                  channel.send( 'echo, ' + event.data );
                }
              };
              
              // var callee_channel = peer.createDataChannel( 'callee_channel', { reliable: false } );
              
              // Calls may be filtered by authorizations based on attributes 'from' and 'to'
              description = v.event;
              
              de&&ug( 'offer description sdp:\n' + description.sdp );
              
              peer.setRemoteDescription( description );
              
              // Answer the call.
              // Acceptance could be performed by an upstream pipelet or by spliting this
              // pipelet in two.
              peer.createAnswer( answer_ready, make_error( 'callee_peer_connection.createAnswer' ) );
              
              function answer_ready( description ) {
                peer.setLocalDescription( description );
                
                // Send description back to caller
                add.call( caller_peer_connection, [
                  { flow: 'webrtc', from: to, to: from, name: 'answer', event: description }
                ] );
              }
            break;
            
            case 'answer':
              description = v.event;
              
              de&&ug( 'answer description sdp:\n' + description.sdp );
              
              this.setRemoteDescription( description );
              
              setTimeout( function() { de&&ug( 'sending data' ); caller_channel.send( 'sent data' ) }, 100 );
            break;
            
            case 'ice_candidate':
              candidate = v.event;
              
              de&&ug( 'ice candidate: ' + log.s( candidate ) );
              
              this.addIceCandidate( new RTCIceCandidate( candidate ) );
            break;
            
            default:
              // unknow event
          }
        }
      } // add()
      
      function on_error( error ) {
        de&&ug( 'get_user_media()#on_error(), error: ' + log.s( error ) );
        
        alert( 'To reset permission denied you need to go to chrome://settings/content # Media, Manage Exceptions' )
      }
      
      function make_error( f ) {
        return function( error ) { de&&ug( f + '() error: ' + log.s( error ) ) }
      }
      
      // xs.socket_io_server();
    </script>
  </body>
</html>
